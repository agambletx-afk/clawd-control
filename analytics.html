<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cost Analytics â€” Clawd Control</title>
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ANALYTICS â€” Page-specific styles
   Layout, sidebar, topbar, theme, design system
   provided by layout.js
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Page Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.page-header {
  margin-bottom: 24px;
}
.page-header h1 {
  font-size: 1.5rem; font-weight: 800; letter-spacing: -0.02em;
  display: flex; align-items: center; gap: 10px;
}
.page-header p {
  font-size: 0.82rem; color: var(--text-tertiary); margin-top: 4px;
}

/* â”€â”€ Stats Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.stats-grid {
  display: grid; grid-template-columns: repeat(4, 1fr);
  gap: 12px; margin-bottom: 16px;
}
.stat-card {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 14px 16px;
  transition: all 0.35s ease;
}
.stat-card:hover { border-color: var(--border); }
[data-theme="light"] .stat-card { box-shadow: var(--shadow-sm); }
.stat-label {
  font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.06em;
  color: var(--text-tertiary); margin-bottom: 4px; font-weight: 600;
}
.stat-value {
  font-size: 1.5rem; font-weight: 800; line-height: 1;
  font-variant-numeric: tabular-nums;
}
.stat-value.accent { color: var(--accent); }
.stat-value.success { color: var(--success); }
.stat-value.info { color: var(--info); }
.stat-sub { font-size: 0.7rem; color: var(--text-tertiary); margin-top: 4px; }

/* â”€â”€ Controls Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.controls {
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  margin-bottom: 16px; padding: 12px 16px;
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md);
}
.control-group { display: flex; align-items: center; gap: 6px; }
.control-label {
  font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.06em; color: var(--text-tertiary);
}
.control-select {
  padding: 6px 10px; border-radius: var(--radius-sm);
  background: var(--bg-primary); border: 1px solid var(--border-subtle);
  color: var(--text-primary); font-family: var(--font-sans);
  font-size: 0.8rem; cursor: pointer;
}
.control-select:focus { border-color: var(--accent); outline: none; }

/* â”€â”€ Chart Containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.chart-row {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 12px; margin-bottom: 12px;
}
.chart-card {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 16px;
  transition: all 0.35s ease;
}
.chart-card:hover { border-color: var(--border); }
[data-theme="light"] .chart-card { box-shadow: var(--shadow-sm); }

.chart-card-full {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 16px;
  margin-bottom: 12px;
}

.chart-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-subtle);
}
.chart-title {
  font-size: 0.85rem; font-weight: 700; color: var(--text-primary);
  display: flex; align-items: center; gap: 6px;
}
.chart-subtitle {
  font-size: 0.7rem; color: var(--text-tertiary);
}

/* â”€â”€ Bar Chart (CSS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.bar-chart { display: flex; flex-direction: column; gap: 8px; min-height: 200px; }
.bar-item { display: flex; align-items: center; gap: 8px; }
.bar-label {
  font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
  min-width: 80px; text-align: right; white-space: nowrap;
  overflow: hidden; text-overflow: ellipsis;
}
.bar-track {
  flex: 1; height: 24px; background: var(--bg-primary);
  border-radius: var(--radius-sm); overflow: hidden; position: relative;
}
.bar-fill {
  height: 100%; border-radius: var(--radius-sm);
  background: linear-gradient(90deg, var(--accent), var(--accent-hover));
  display: flex; align-items: center; justify-content: flex-end;
  padding: 0 8px; font-size: 0.7rem; font-weight: 700;
  color: var(--bg-primary); transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  min-width: 32px;
}
.bar-value {
  font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text-primary); min-width: 50px; text-align: right;
}

/* â”€â”€ Line Chart (Canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.line-chart-container { position: relative; height: 200px; }
.line-chart { width: 100%; height: 100%; }

/* â”€â”€ Token Breakdown (Pie-style bars) â”€â”€â”€â”€ */
.token-breakdown { display: flex; flex-direction: column; gap: 10px; }
.token-item { display: flex; flex-direction: column; gap: 4px; }
.token-header { display: flex; justify-content: space-between; align-items: center; }
.token-label { font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); }
.token-value { font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums; }
.token-bar {
  height: 8px; border-radius: 4px; background: var(--bg-primary);
  overflow: hidden;
}
.token-fill {
  height: 100%; border-radius: 4px;
  transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
}
.token-fill.input { background: #3b82f6; }
.token-fill.output { background: #22c55e; }
.token-fill.cache { background: #c9a44a; }

/* â”€â”€ Session List â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.session-list { display: flex; flex-direction: column; gap: 6px; }
.session-list-item {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 10px; background: var(--bg-primary);
  border-radius: var(--radius-sm); font-size: 0.78rem;
  transition: background 0.2s;
}
.session-list-item:hover { background: var(--bg-secondary); }
.session-agent {
  font-weight: 600; color: var(--text-primary);
  display: flex; align-items: center; gap: 6px;
}
.session-agent-emoji { font-size: 1rem; }
.session-meta {
  display: flex; align-items: center; gap: 10px;
  font-size: 0.7rem; color: var(--text-tertiary);
}
.session-cost {
  font-weight: 700; color: var(--accent);
  font-variant-numeric: tabular-nums;
}
.session-tokens {
  font-variant-numeric: tabular-nums;
}

/* â”€â”€ Model Distribution (CSS Donut) â”€â”€â”€â”€â”€â”€ */
.model-distribution { display: flex; flex-direction: column; gap: 8px; }
.model-item {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 0; border-bottom: 1px solid var(--border-subtle);
}
.model-item:last-child { border-bottom: none; }
.model-color {
  width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0;
}
.model-name {
  flex: 1; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
}
.model-percent {
  font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text-primary);
}

/* â”€â”€ Tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.chart-tooltip {
  position: absolute; pointer-events: none;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-sm); padding: 10px 14px;
  font-size: 0.75rem; z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,.3);
  transition: opacity 0.15s;
  min-width: 160px;
}
.chart-tooltip.hidden { opacity: 0; }
.tooltip-date { font-weight: 700; color: var(--text-primary); margin-bottom: 6px; }
.tooltip-row { display: flex; justify-content: space-between; gap: 12px; margin: 2px 0; }
.tooltip-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; }
.tooltip-label { color: var(--text-secondary); }
.tooltip-val { font-weight: 700; font-variant-numeric: tabular-nums; color: var(--text-primary); }

/* â”€â”€ View Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.view-toggle {
  display: flex; gap: 2px; background: var(--bg-primary);
  border-radius: var(--radius-sm); padding: 2px;
}
.view-toggle button {
  padding: 4px 10px; border: none; border-radius: var(--radius-sm);
  background: transparent; color: var(--text-tertiary); cursor: pointer;
  font-size: 0.7rem; font-weight: 600; font-family: var(--font-sans);
  transition: all 0.2s;
}
.view-toggle button.active {
  background: var(--surface); color: var(--text-primary);
  box-shadow: 0 1px 3px rgba(0,0,0,.2);
}

/* â”€â”€ Cost by Model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.cost-model-list { display: flex; flex-direction: column; gap: 8px; min-height: 200px; }
.cost-model-item {
  display: flex; align-items: center; gap: 10px;
  padding: 8px 10px; background: var(--bg-primary);
  border-radius: var(--radius-sm);
}
.cost-model-color { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }
.cost-model-name { flex: 1; font-size: 0.78rem; font-weight: 600; color: var(--text-secondary); }
.cost-model-amount { font-size: 0.82rem; font-weight: 800; color: var(--accent); font-variant-numeric: tabular-nums; }
.cost-model-tokens { font-size: 0.68rem; color: var(--text-tertiary); font-variant-numeric: tabular-nums; }
.cost-model-rate { font-size: 0.65rem; color: var(--text-tertiary); }
.cost-model-bar { flex: 0 0 80px; height: 6px; background: var(--bg-secondary); border-radius: 3px; overflow: hidden; }
.cost-model-fill { height: 100%; border-radius: 3px; transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1); }

/* â”€â”€ Projection Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.projection-grid {
  display: grid; grid-template-columns: repeat(3, 1fr);
  gap: 12px; min-height: 100px;
}
.projection-item {
  text-align: center; padding: 16px 12px;
  background: var(--bg-primary); border-radius: var(--radius-md);
}
.projection-value {
  font-size: 1.8rem; font-weight: 800; line-height: 1;
  font-variant-numeric: tabular-nums; color: var(--accent);
}
.projection-label {
  font-size: 0.7rem; color: var(--text-tertiary); margin-top: 6px;
  text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;
}
.projection-sub {
  font-size: 0.68rem; color: var(--text-secondary); margin-top: 4px;
}

/* â”€â”€ Loading State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.loading-state {
  text-align: center; padding: 40px 20px; color: var(--text-tertiary);
}
.loading-state .icon { font-size: 2rem; margin-bottom: 12px; opacity: 0.4; }
.loading-state p { font-size: 0.85rem; }

/* â”€â”€ Empty State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.empty-state {
  text-align: center; padding: 40px 20px; color: var(--text-secondary);
}
.empty-state .icon { font-size: 2rem; margin-bottom: 12px; opacity: 0.4; }
.empty-state p { font-size: 0.85rem; }

/* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 900px) {
  .stats-grid { grid-template-columns: repeat(2, 1fr); }
  .chart-row { grid-template-columns: 1fr; }
  .projection-grid { grid-template-columns: 1fr; }
}

@keyframes fadeUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.fade-up { animation: fadeUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) both; }
</style>
</head>
<body>

<main class="main">
  <div class="page-header fade-up">
    <h1>ğŸ“Š Cost Analytics</h1>
    <p>Token usage and cost breakdown across all agents</p>
  </div>

  <div class="controls fade-up" style="animation-delay:.05s">
    <div class="control-group">
      <span class="control-label">Time Range</span>
      <select class="control-select" id="rangeSelect" onchange="loadAnalytics()">
        <option value="7">Last 7 Days</option>
        <option value="30">Last 30 Days</option>
        <option value="90">Last 90 Days</option>
        <option value="all">All Time</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Agent</span>
      <select class="control-select" id="agentSelect" onchange="loadAnalytics()">
        <option value="all">All Agents</option>
      </select>
    </div>
  </div>

  <div class="stats-grid fade-up" style="animation-delay:.1s">
    <div class="stat-card">
      <div class="stat-label">Total Cost</div>
      <div class="stat-value accent" id="statTotalCost">â€”</div>
      <div class="stat-sub" id="statCostSub">Loading...</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Total Tokens</div>
      <div class="stat-value info" id="statTotalTokens">â€”</div>
      <div class="stat-sub" id="statTokensSub">All messages</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">API Calls</div>
      <div class="stat-value success" id="statApiCalls">â€”</div>
      <div class="stat-sub" id="statCallsSub">Messages sent</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Projected Monthly</div>
      <div class="stat-value" style="color: var(--accent)" id="statProjected">â€”</div>
      <div class="stat-sub" id="statProjectedSub">At current rate</div>
    </div>
  </div>

  <div class="chart-row fade-up" style="animation-delay:.15s">
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="bar-chart-3"></i>
          Cost by Agent
        </div>
      </div>
      <div id="costByAgentChart" class="bar-chart">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>

    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="pie-chart"></i>
          Token Breakdown
        </div>
      </div>
      <div id="tokenBreakdownChart" class="token-breakdown">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="chart-card-full fade-up" style="animation-delay:.2s">
    <div class="chart-header">
      <div class="chart-title">
        <i data-lucide="trending-up"></i>
        Cost Over Time
      </div>
      <div style="display:flex;align-items:center;gap:10px">
        <div class="chart-subtitle" id="costTimeSubtitle">Daily breakdown</div>
        <div class="view-toggle">
          <button class="active" onclick="setCostMode('daily', this)">Daily</button>
          <button onclick="setCostMode('cumulative', this)">Cumulative</button>
        </div>
      </div>
    </div>
    <div class="line-chart-container">
      <canvas id="costOverTimeChart" class="line-chart"></canvas>
      <div class="chart-tooltip hidden" id="costTooltip"></div>
    </div>
  </div>

  <div class="chart-row fade-up" style="animation-delay:.25s">
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="flame"></i>
          Top Expensive Sessions
        </div>
      </div>
      <div id="topSessionsList" class="session-list">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading sessions...</p>
        </div>
      </div>
    </div>

    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="cpu"></i>
          Cost by Model
        </div>
      </div>
      <div id="costByModelChart" class="cost-model-list">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading models...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="chart-card-full fade-up" style="animation-delay:.3s">
    <div class="chart-header">
      <div class="chart-title">
        <i data-lucide="calculator"></i>
        Cost Projections
      </div>
      <div class="chart-subtitle">Based on current usage patterns</div>
    </div>
    <div id="projectionsPanel" class="projection-grid">
      <div class="loading-state"><div class="icon">â³</div><p>Loading...</p></div>
    </div>
  </div>

  <div class="chart-card-full fade-up" id="agentCostSection" style="animation-delay:.35s;display:none">
    <div class="chart-header">
      <div class="chart-title">
        <i data-lucide="git-compare"></i>
        Daily Cost by Agent
      </div>
      <div class="chart-subtitle">Stacked daily cost breakdown per agent</div>
    </div>
    <div class="line-chart-container">
      <canvas id="agentCostChart" class="line-chart"></canvas>
      <div class="chart-tooltip hidden" id="agentCostTooltip"></div>
    </div>
  </div>

</main>

<script src="/layout.js"></script>
<script>
'use strict';

const $ = s => document.querySelector(s);
let analyticsData = null;
let tokenData = null;
let costMode = 'daily';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.addEventListener('layout:snapshot', () => {
  populateAgentSelect();
  loadAnalytics();
});

setTimeout(() => { if (!analyticsData) loadAnalytics(); }, 500);

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => { if (analyticsData) renderAll(); }, 200);
});

function populateAgentSelect() {
  const select = $('#agentSelect');
  const ids = Object.keys(agentState).sort();
  const agentOptions = ids.map(id => {
    const a = agentState[id];
    return `<option value="${id}">${a.emoji || 'ğŸ¤–'} ${a.name || id}</option>`;
  }).join('');
  select.innerHTML = '<option value="all">All Agents</option>' + agentOptions;
}

function setCostMode(mode, btn) {
  costMode = mode;
  document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  renderCostOverTime();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOAD DATA (both endpoints)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function loadAnalytics() {
  const range = $('#rangeSelect').value;
  const agent = $('#agentSelect').value;

  try {
    const [aRes, tRes] = await Promise.all([
      fetch(`/api/analytics?range=${range}&agent=${agent}`),
      fetch(`/api/tokens?range=${range}&agent=${agent}`)
    ]);
    analyticsData = await aRes.json();
    tokenData = await tRes.json();
    renderAll();
  } catch (e) {
    console.error('Failed to load analytics:', e);
    if (typeof showToast === 'function') showToast('Failed to load analytics data', 'error');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAll() {
  if (!analyticsData) return;

  renderStats();
  renderCostByAgent();
  renderTokenBreakdown();
  renderCostOverTime();
  renderTopSessions();
  renderCostByModel();
  renderProjections();
  renderAgentCostChart();

  refreshIcons();
}

function renderStats() {
  const d = analyticsData;

  $('#statTotalCost').textContent = d.totalCost > 0 ? `$${d.totalCost.toFixed(2)}` : '$0.00';
  $('#statCostSub').textContent = d.range === 'all' ? 'All time' : `Last ${d.range} days`;

  $('#statTotalTokens').textContent = formatNumber(d.totalTokens);
  $('#statTokensSub').textContent = `${formatNumber(d.inputTokens + d.outputTokens)} in/out`;

  $('#statApiCalls').textContent = formatNumber(d.apiCalls);
  $('#statCallsSub').textContent = 'Messages sent';

  // Monthly projection
  const days = d.overTime?.length || 1;
  const dailyAvg = d.totalCost / days;
  const monthly = dailyAvg * 30;
  $('#statProjected').textContent = monthly > 0 ? `$${monthly.toFixed(2)}` : '$0.00';
  $('#statProjectedSub').textContent = `$${dailyAvg.toFixed(3)}/day avg`;
}

function renderCostByAgent() {
  const container = $('#costByAgentChart');
  const agents = analyticsData.byAgent;

  if (!agents || agents.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No cost data</p></div>';
    return;
  }

  const maxCost = Math.max(...agents.map(a => a.cost));

  container.innerHTML = agents.map(a => {
    const pct = maxCost > 0 ? (a.cost / maxCost * 100) : 0;
    const agentInfo = agentState[a.agentId] || {};
    const emoji = agentInfo.emoji || 'ğŸ¤–';
    const name = agentInfo.name || a.agentId;
    return `
      <div class="bar-item">
        <div class="bar-label" title="${name}">${emoji} ${truncate(name, 10)}</div>
        <div class="bar-track">
          <div class="bar-fill" style="width:${pct}%">$${a.cost.toFixed(2)}</div>
        </div>
        <div class="bar-value">${formatNumber(a.tokens)} tok</div>
      </div>
    `;
  }).join('');
}

function renderTokenBreakdown() {
  const container = $('#tokenBreakdownChart');
  const d = analyticsData;

  const total = d.inputTokens + d.outputTokens + d.cacheReadTokens;
  if (total === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No token data</p></div>';
    return;
  }

  const items = [
    { label: 'Input Tokens', value: d.inputTokens, class: 'input' },
    { label: 'Output Tokens', value: d.outputTokens, class: 'output' },
    { label: 'Cache Reads', value: d.cacheReadTokens, class: 'cache' },
  ];

  container.innerHTML = items.map(item => {
    const pct = (item.value / total * 100).toFixed(1);
    return `
      <div class="token-item">
        <div class="token-header">
          <span class="token-label">${item.label}</span>
          <span class="token-value">${formatNumber(item.value)} (${pct}%)</span>
        </div>
        <div class="token-bar">
          <div class="token-fill ${item.class}" style="width:${pct}%"></div>
        </div>
      </div>
    `;
  }).join('');
}

function renderCostOverTime() {
  const canvas = $('#costOverTimeChart');
  const ctx = canvas.getContext('2d');
  const tooltip = $('#costTooltip');
  const timeline = analyticsData.overTime || [];

  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth * 2;
  canvas.height = parent.clientHeight * 2;
  canvas.style.width = parent.clientWidth + 'px';
  canvas.style.height = parent.clientHeight + 'px';
  ctx.scale(2, 2);

  if (timeline.length === 0) {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-tertiary');
    ctx.font = '12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No data available', parent.clientWidth / 2, parent.clientHeight / 2);
    return;
  }

  const w = parent.clientWidth;
  const h = parent.clientHeight;
  const padding = { top: 20, right: 20, bottom: 30, left: 55 };
  const chartW = w - padding.left - padding.right;
  const chartH = h - padding.top - padding.bottom;

  const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
  const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-subtle').trim();
  const isCumulative = costMode === 'cumulative';

  // Build cumulative data
  let running = 0;
  const cumData = timeline.map(d => { running += d.cost; return { ...d, cumulative: running }; });
  const maxCost = isCumulative
    ? Math.max(running, 0.01)
    : Math.max(...timeline.map(d => d.cost), 0.01);

  // Grid
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = padding.top + (chartH / 4) * i;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartW, y);
    ctx.stroke();
    const value = maxCost * (1 - i / 4);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`$${value < 1 ? value.toFixed(3) : value.toFixed(2)}`, padding.left - 8, y + 3);
  }

  const baseY = padding.top + chartH;
  const costPoints = cumData.map((d, i) => {
    const x = padding.left + (chartW / (timeline.length - 1 || 1)) * i;
    const val = isCumulative ? d.cumulative : d.cost;
    const y = padding.top + chartH - (val / maxCost * chartH);
    return { x, y, cost: d.cost, cumulative: d.cumulative, date: d.date, tokens: d.tokens };
  });

  // Area
  ctx.fillStyle = accentColor + '20';
  ctx.beginPath();
  ctx.moveTo(costPoints[0].x, baseY);
  costPoints.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(costPoints[costPoints.length - 1].x, baseY);
  ctx.closePath();
  ctx.fill();

  // Line
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.beginPath();
  costPoints.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
  ctx.stroke();

  // Dots
  costPoints.forEach(p => {
    ctx.fillStyle = accentColor;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
  });

  // X-axis
  ctx.fillStyle = textColor;
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(timeline.length / 7));
  timeline.forEach((d, i) => {
    if (i % step === 0 || i === timeline.length - 1) {
      ctx.fillText(formatDate(d.date), costPoints[i].x, baseY + 18);
    }
  });

  // Tooltip
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    let closest = null, minDist = Infinity;
    for (const p of costPoints) {
      const dist = Math.abs(p.x - mx);
      if (dist < minDist) { minDist = dist; closest = p; }
    }
    if (closest && minDist < 30) {
      tooltip.classList.remove('hidden');
      tooltip.innerHTML = `
        <div class="tooltip-date">${closest.date}</div>
        <div class="tooltip-row"><span class="tooltip-label">Daily Cost</span><span class="tooltip-val" style="color:var(--accent)">$${closest.cost.toFixed(4)}</span></div>
        <div class="tooltip-row"><span class="tooltip-label">Running Total</span><span class="tooltip-val">$${closest.cumulative.toFixed(4)}</span></div>
        <div class="tooltip-row"><span class="tooltip-label">Tokens</span><span class="tooltip-val">${formatNumber(closest.tokens)}</span></div>
      `;
      const tx = Math.min(e.clientX - rect.left + 12, rect.width - 180);
      tooltip.style.left = tx + 'px';
      tooltip.style.top = Math.max(e.clientY - rect.top - 70, 0) + 'px';
    } else {
      tooltip.classList.add('hidden');
    }
  };
  canvas.onmouseleave = () => tooltip.classList.add('hidden');
}

function renderTopSessions() {
  const container = $('#topSessionsList');
  const sessions = analyticsData.topSessions || [];

  if (sessions.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No sessions found</p></div>';
    return;
  }

  container.innerHTML = sessions.slice(0, 8).map(s => {
    const agentInfo = agentState[s.agentId] || {};
    const emoji = agentInfo.emoji || 'ğŸ¤–';
    const name = agentInfo.name || s.agentId;
    return `
      <div class="session-list-item">
        <div class="session-agent">
          <span class="session-agent-emoji">${emoji}</span>
          <span>${truncate(name, 12)}</span>
        </div>
        <div class="session-meta">
          <span class="session-tokens">${formatNumber(s.tokens)} tok</span>
          <span class="session-cost">$${s.cost.toFixed(3)}</span>
        </div>
      </div>
    `;
  }).join('');
}

function renderCostByModel() {
  const container = $('#costByModelChart');
  const models = tokenData?.byModel || analyticsData?.byModel || [];

  if (models.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No model data</p></div>';
    return;
  }

  const maxCost = Math.max(...models.map(m => m.cost || 0), 0.001);
  const colors = ['#3b82f6', '#22c55e', '#c9a44a', '#ef4444', '#8b5cf6', '#f59e0b', '#06b6d4', '#ec4899'];

  container.innerHTML = models.filter(m => m.cost > 0).slice(0, 8).map((m, i) => {
    const pct = ((m.cost || 0) / maxCost * 100);
    const color = colors[i % colors.length];
    const tokens = (m.inputTokens || 0) + (m.outputTokens || 0) + (m.cacheReadTokens || 0);
    const costPer1k = tokens > 0 ? ((m.cost || 0) / tokens * 1000) : 0;
    const cleanModel = (m.model || '').replace('anthropic/', '').replace('openai/', '');

    return `
      <div class="cost-model-item">
        <div class="cost-model-color" style="background:${color}"></div>
        <div style="flex:1;min-width:0">
          <div class="cost-model-name">${escapeHtml(truncate(cleanModel, 24))}</div>
          <div class="cost-model-rate">${formatNumber(tokens)} tok Â· $${costPer1k.toFixed(4)}/1K</div>
        </div>
        <div style="text-align:right">
          <div class="cost-model-amount">$${(m.cost || 0).toFixed(3)}</div>
        </div>
        <div class="cost-model-bar">
          <div class="cost-model-fill" style="width:${pct}%;background:${color}"></div>
        </div>
      </div>
    `;
  }).join('');
}

function renderProjections() {
  const container = $('#projectionsPanel');
  const d = analyticsData;
  const timeline = d.overTime || [];

  if (timeline.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No data for projections</p></div>';
    return;
  }

  const days = timeline.length;
  const dailyAvg = d.totalCost / days;
  const weekly = dailyAvg * 7;
  const monthly = dailyAvg * 30;
  const yearly = dailyAvg * 365;

  // Trend: compare last 7 days vs previous 7 days
  const last7 = timeline.slice(-7).reduce((s, d) => s + d.cost, 0);
  const prev7 = timeline.slice(-14, -7).reduce((s, d) => s + d.cost, 0);
  const trendPct = prev7 > 0 ? ((last7 - prev7) / prev7 * 100) : 0;
  const trendDir = trendPct > 5 ? 'ğŸ“ˆ' : trendPct < -5 ? 'ğŸ“‰' : 'â¡ï¸';
  const trendColor = trendPct > 5 ? 'var(--warning)' : trendPct < -5 ? 'var(--success)' : 'var(--text-secondary)';

  // Cost per API call
  const costPerCall = d.apiCalls > 0 ? (d.totalCost / d.apiCalls) : 0;

  // Peak day
  const peakDay = timeline.reduce((max, d) => d.cost > max.cost ? d : max, timeline[0]);

  container.innerHTML = `
    <div class="projection-item">
      <div class="projection-value">$${monthly.toFixed(2)}</div>
      <div class="projection-label">Monthly Estimate</div>
      <div class="projection-sub">$${yearly.toFixed(2)}/year Â· $${weekly.toFixed(2)}/week</div>
    </div>
    <div class="projection-item">
      <div class="projection-value" style="color:${trendColor}">${trendDir} ${Math.abs(trendPct).toFixed(0)}%</div>
      <div class="projection-label">Week-over-Week</div>
      <div class="projection-sub">$${last7.toFixed(3)} vs $${prev7.toFixed(3)}</div>
    </div>
    <div class="projection-item">
      <div class="projection-value" style="font-size:1.4rem">$${costPerCall.toFixed(4)}</div>
      <div class="projection-label">Cost per API Call</div>
      <div class="projection-sub">Peak: $${peakDay.cost.toFixed(3)} on ${formatDate(peakDay.date)}</div>
    </div>
  `;
}

function renderAgentCostChart() {
  const section = $('#agentCostSection');
  const agentTS = tokenData?.agentTimeSeries || {};
  const agentIds = Object.keys(agentTS);

  if ($('#agentSelect').value !== 'all' || agentIds.length < 2) {
    section.style.display = 'none';
    return;
  }
  section.style.display = '';

  const canvas = $('#agentCostChart');
  const ctx = canvas.getContext('2d');
  const tooltip = $('#agentCostTooltip');

  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth * 2;
  canvas.height = parent.clientHeight * 2;
  canvas.style.width = parent.clientWidth + 'px';
  canvas.style.height = parent.clientHeight + 'px';
  ctx.scale(2, 2);

  const w = parent.clientWidth;
  const h = parent.clientHeight;
  const padding = { top: 20, right: 20, bottom: 40, left: 55 };
  const chartW = w - padding.left - padding.right;
  const chartH = h - padding.top - padding.bottom;

  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
  const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-subtle').trim();
  const agentColors = ['#3b82f6', '#22c55e', '#c9a44a', '#ef4444', '#8b5cf6', '#f59e0b', '#06b6d4', '#ec4899'];

  // Build unified date axis
  const allDates = new Set();
  for (const id of agentIds) for (const dp of agentTS[id]) allDates.add(dp.date);
  const dates = [...allDates].sort();
  if (dates.length === 0) { section.style.display = 'none'; return; }

  // Build lookup
  const lookup = {};
  for (const id of agentIds) {
    lookup[id] = {};
    for (const dp of agentTS[id]) lookup[id][dp.date] = dp.cost;
  }

  // Stacked bar chart â€” compute stacked totals per date
  const stackedMax = Math.max(...dates.map(date =>
    agentIds.reduce((sum, id) => sum + (lookup[id]?.[date] || 0), 0)
  ), 0.001);

  // Grid
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = padding.top + (chartH / 4) * i;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartW, y);
    ctx.stroke();
    const value = stackedMax * (1 - i / 4);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`$${value < 1 ? value.toFixed(3) : value.toFixed(2)}`, padding.left - 8, y + 3);
  }

  const baseY = padding.top + chartH;
  const barW = Math.max(2, Math.min(20, chartW / dates.length - 2));

  // Draw stacked bars
  dates.forEach((date, i) => {
    const x = padding.left + (chartW / (dates.length - 1 || 1)) * i - barW / 2;
    let stackY = baseY;

    agentIds.forEach((id, idx) => {
      const cost = lookup[id]?.[date] || 0;
      if (cost <= 0) return;
      const barH = (cost / stackedMax) * chartH;
      ctx.fillStyle = agentColors[idx % agentColors.length];
      ctx.fillRect(x, stackY - barH, barW, barH);
      stackY -= barH;
    });
  });

  // X-axis
  ctx.fillStyle = textColor;
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(dates.length / 7));
  dates.forEach((d, i) => {
    if (i % step === 0 || i === dates.length - 1) {
      const x = padding.left + (chartW / (dates.length - 1 || 1)) * i;
      ctx.fillText(formatDate(d), x, baseY + 18);
    }
  });

  // Legend
  let legendX = padding.left;
  agentIds.forEach((id, idx) => {
    const color = agentColors[idx % agentColors.length];
    const info = window.agentState?.[id] || {};
    const label = (info.emoji || '') + ' ' + (info.name || id);
    ctx.fillStyle = color;
    ctx.fillRect(legendX, baseY + 28, 10, 10);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(truncate(label, 12), legendX + 14, baseY + 37);
    legendX += 100;
  });

  // Tooltip
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    let closestIdx = 0, minDist = Infinity;
    dates.forEach((_, i) => {
      const x = padding.left + (chartW / (dates.length - 1 || 1)) * i;
      const dist = Math.abs(x - mx);
      if (dist < minDist) { minDist = dist; closestIdx = i; }
    });
    if (minDist < 30) {
      const date = dates[closestIdx];
      const total = agentIds.reduce((s, id) => s + (lookup[id]?.[date] || 0), 0);
      tooltip.classList.remove('hidden');
      let rows = `<div class="tooltip-date">${date}</div>`;
      agentIds.forEach((id, idx) => {
        const cost = lookup[id]?.[date] || 0;
        if (cost <= 0) return;
        const info = window.agentState?.[id] || {};
        const color = agentColors[idx % agentColors.length];
        rows += `<div class="tooltip-row"><span><span class="tooltip-dot" style="background:${color}"></span><span class="tooltip-label">${escapeHtml(info.name || id)}</span></span><span class="tooltip-val" style="color:var(--accent)">$${cost.toFixed(4)}</span></div>`;
      });
      rows += `<div class="tooltip-row" style="border-top:1px solid var(--border-subtle);padding-top:4px;margin-top:4px"><span class="tooltip-label">Total</span><span class="tooltip-val">$${total.toFixed(4)}</span></div>`;
      tooltip.innerHTML = rows;
      const tx = Math.min(e.clientX - rect.left + 12, rect.width - 180);
      tooltip.style.left = tx + 'px';
      tooltip.style.top = Math.max(e.clientY - rect.top - 60, 0) + 'px';
    } else {
      tooltip.classList.add('hidden');
    }
  };
  canvas.onmouseleave = () => tooltip.classList.add('hidden');
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function formatNumber(n) {
  if (n > 1e6) return (n / 1e6).toFixed(1) + 'M';
  if (n > 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toString();
}

function formatDate(dateStr) {
  const d = new Date(dateStr);
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  return `${month}/${day}`;
}

function truncate(str, max) {
  if (str.length <= max) return str;
  return str.slice(0, max - 1) + 'â€¦';
}

</script>
<script src="/lucide.min.js"></script>
<script>lucide.createIcons();</script>
</body>
</html>

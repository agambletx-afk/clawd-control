<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Token Usage â€” Clawd Control</title>
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOKEN USAGE â€” Page-specific styles
   Layout, sidebar, topbar, theme, design system
   provided by layout.js
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Page Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.page-header {
  margin-bottom: 24px;
}
.page-header h1 {
  font-size: 1.5rem; font-weight: 800; letter-spacing: -0.02em;
  display: flex; align-items: center; gap: 10px;
}
.page-header p {
  font-size: 0.82rem; color: var(--text-tertiary); margin-top: 4px;
}

/* â”€â”€ Stats Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.stats-grid {
  display: grid; grid-template-columns: repeat(4, 1fr);
  gap: 12px; margin-bottom: 16px;
}
.stat-card {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 14px 16px;
  transition: all 0.35s ease;
}
.stat-card:hover { border-color: var(--border); }
[data-theme="light"] .stat-card { box-shadow: var(--shadow-sm); }
.stat-label {
  font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.06em;
  color: var(--text-tertiary); margin-bottom: 4px; font-weight: 600;
}
.stat-value {
  font-size: 1.5rem; font-weight: 800; line-height: 1;
  font-variant-numeric: tabular-nums;
}
.stat-value.accent { color: var(--accent); }
.stat-value.success { color: var(--success); }
.stat-value.info { color: var(--info); }
.stat-value.cache { color: var(--accent); }
.stat-sub { font-size: 0.7rem; color: var(--text-tertiary); margin-top: 4px; }

/* â”€â”€ Controls Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.controls {
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
  margin-bottom: 16px; padding: 12px 16px;
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md);
}
.control-group { display: flex; align-items: center; gap: 6px; }
.control-label {
  font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.06em; color: var(--text-tertiary);
}
.control-select {
  padding: 6px 10px; border-radius: var(--radius-sm);
  background: var(--bg-primary); border: 1px solid var(--border-subtle);
  color: var(--text-primary); font-family: var(--font-sans);
  font-size: 0.8rem; cursor: pointer;
}
.control-select:focus { border-color: var(--accent); outline: none; }

/* â”€â”€ Chart Containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.chart-row {
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 12px; margin-bottom: 12px;
}
.chart-card {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 16px;
  transition: all 0.35s ease;
}
.chart-card:hover { border-color: var(--border); }
[data-theme="light"] .chart-card { box-shadow: var(--shadow-sm); }

.chart-card-full {
  background: var(--surface); border: 1px solid var(--border-subtle);
  border-radius: var(--radius-md); padding: 16px;
  margin-bottom: 12px;
}

.chart-header {
  display: flex; justify-content: space-between; align-items: center;
  margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-subtle);
}
.chart-title {
  font-size: 0.85rem; font-weight: 700; color: var(--text-primary);
  display: flex; align-items: center; gap: 6px;
}
.chart-subtitle {
  font-size: 0.7rem; color: var(--text-tertiary);
}

/* â”€â”€ Line Chart (Canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.line-chart-container { position: relative; height: 280px; }
.line-chart { width: 100%; height: 100%; }

/* â”€â”€ Donut Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.donut-container {
  display: flex; align-items: center; justify-content: center;
  min-height: 200px; gap: 20px;
}
.donut-canvas { width: 160px; height: 160px; }
.donut-legend { display: flex; flex-direction: column; gap: 8px; }
.donut-legend-item {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 0; border-bottom: 1px solid var(--border-subtle);
}
.donut-legend-item:last-child { border-bottom: none; }
.donut-color {
  width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0;
}
.donut-label {
  flex: 1; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
}
.donut-value {
  font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text-primary);
}

/* â”€â”€ Bar Chart (CSS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.bar-chart { display: flex; flex-direction: column; gap: 10px; min-height: 200px; }
.bar-item { display: flex; flex-direction: column; gap: 4px; }
.bar-header { display: flex; justify-content: space-between; align-items: center; }
.bar-label {
  font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
  display: flex; align-items: center; gap: 6px;
}
.bar-total {
  font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text-primary);
}
.bar-track {
  height: 28px; background: var(--bg-primary);
  border-radius: var(--radius-sm); overflow: hidden; position: relative;
  display: flex;
}
.bar-segment {
  height: 100%; display: flex; align-items: center; justify-content: center;
  font-size: 0.65rem; font-weight: 700; color: white;
  transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
}
.bar-segment.input { background: #3b82f6; }
.bar-segment.output { background: #22c55e; }
.bar-segment.cache { background: #c9a44a; }

/* â”€â”€ Cache Efficiency Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.cache-metrics {
  display: grid; grid-template-columns: repeat(2, 1fr);
  gap: 16px; min-height: 200px;
}
.cache-metric {
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; text-align: center;
  background: var(--bg-primary); border-radius: var(--radius-md);
  padding: 20px;
}
.cache-metric-value {
  font-size: 2.5rem; font-weight: 800; line-height: 1;
  font-variant-numeric: tabular-nums;
}
.cache-metric-value.good { color: var(--success); }
.cache-metric-value.warn { color: var(--warning); }
.cache-metric-value.info { color: var(--info); }
.cache-metric-label {
  font-size: 0.75rem; color: var(--text-tertiary); margin-top: 8px;
  text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;
}
.cache-metric-sub {
  font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px;
}

/* â”€â”€ Tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.chart-tooltip {
  position: absolute; pointer-events: none;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-sm); padding: 10px 14px;
  font-size: 0.75rem; z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,.3);
  transition: opacity 0.15s;
  min-width: 160px;
}
.chart-tooltip.hidden { opacity: 0; }
.tooltip-date { font-weight: 700; color: var(--text-primary); margin-bottom: 6px; }
.tooltip-row { display: flex; justify-content: space-between; gap: 12px; margin: 2px 0; }
.tooltip-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; }
.tooltip-label { color: var(--text-secondary); }
.tooltip-val { font-weight: 700; font-variant-numeric: tabular-nums; color: var(--text-primary); }

/* â”€â”€ View Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.view-toggle {
  display: flex; gap: 2px; background: var(--bg-primary);
  border-radius: var(--radius-sm); padding: 2px;
}
.view-toggle button {
  padding: 4px 10px; border: none; border-radius: var(--radius-sm);
  background: transparent; color: var(--text-tertiary); cursor: pointer;
  font-size: 0.7rem; font-weight: 600; font-family: var(--font-sans);
  transition: all 0.2s;
}
.view-toggle button.active {
  background: var(--surface); color: var(--text-primary);
  box-shadow: 0 1px 3px rgba(0,0,0,.2);
}

/* â”€â”€ Model Bar Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.model-bar-chart { display: flex; flex-direction: column; gap: 10px; min-height: 200px; }
.model-bar-item { display: flex; flex-direction: column; gap: 4px; }
.model-bar-header { display: flex; justify-content: space-between; align-items: center; }
.model-bar-name {
  font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
  display: flex; align-items: center; gap: 6px;
}
.model-bar-name .model-dot { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }
.model-bar-tokens {
  font-size: 0.72rem; font-weight: 700; font-variant-numeric: tabular-nums;
  color: var(--text-primary);
}
.model-bar-cost {
  font-size: 0.65rem; color: var(--accent); font-weight: 600;
}
.model-bar-track {
  height: 24px; background: var(--bg-primary);
  border-radius: var(--radius-sm); overflow: hidden;
  display: flex;
}
.model-bar-segment {
  height: 100%; display: flex; align-items: center; justify-content: center;
  font-size: 0.6rem; font-weight: 700; color: white;
  transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
}

/* â”€â”€ Loading State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.loading-state {
  text-align: center; padding: 40px 20px; color: var(--text-tertiary);
}
.loading-state .icon { font-size: 2rem; margin-bottom: 12px; opacity: 0.4; }
.loading-state p { font-size: 0.85rem; }

/* â”€â”€ Empty State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.empty-state {
  text-align: center; padding: 40px 20px; color: var(--text-secondary);
}
.empty-state .icon { font-size: 2rem; margin-bottom: 12px; opacity: 0.4; }
.empty-state p { font-size: 0.85rem; }

/* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 900px) {
  .stats-grid { grid-template-columns: repeat(2, 1fr); }
  .chart-row { grid-template-columns: 1fr; }
  .cache-metrics { grid-template-columns: 1fr; }
}

@keyframes fadeUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.fade-up { animation: fadeUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) both; }
</style>
</head>
<body>

<main class="main">
  <div class="page-header fade-up">
    <h1>ğŸ¯ Token Usage</h1>
    <p>Token consumption trends and cache efficiency across all agents</p>
  </div>

  <div class="controls fade-up" style="animation-delay:.05s">
    <div class="control-group">
      <span class="control-label">Time Range</span>
      <select class="control-select" id="rangeSelect" onchange="loadTokens()">
        <option value="7">Last 7 Days</option>
        <option value="30" selected>Last 30 Days</option>
        <option value="90">Last 90 Days</option>
        <option value="all">All Time</option>
      </select>
    </div>
    <div class="control-group">
      <span class="control-label">Agent</span>
      <select class="control-select" id="agentSelect" onchange="loadTokens()">
        <option value="all">All Agents</option>
      </select>
    </div>
  </div>

  <div class="stats-grid fade-up" style="animation-delay:.1s">
    <div class="stat-card">
      <div class="stat-label">Total Tokens</div>
      <div class="stat-value info" id="statTotalTokens">â€”</div>
      <div class="stat-sub" id="statTokensSub">Loading...</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Avg Tokens/Call</div>
      <div class="stat-value" id="statAvgTokens">â€”</div>
      <div class="stat-sub" id="statAvgSub">Per API call</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Cache Hit Rate</div>
      <div class="stat-value cache" id="statCacheRate">â€”</div>
      <div class="stat-sub" id="statCacheSub">Efficiency</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Total Cost</div>
      <div class="stat-value accent" id="statTotalCost">â€”</div>
      <div class="stat-sub" id="statCostSub">All messages</div>
    </div>
  </div>

  <div class="chart-card-full fade-up" style="animation-delay:.15s">
    <div class="chart-header">
      <div class="chart-title">
        <i data-lucide="trending-up"></i>
        Daily Token Usage
      </div>
      <div style="display:flex;align-items:center;gap:10px">
        <div class="chart-subtitle" id="dailySubtitle">Input, output, and cache tokens over time</div>
        <div class="view-toggle">
          <button class="active" onclick="setChartMode('lines', this)">Lines</button>
          <button onclick="setChartMode('stacked', this)">Stacked</button>
        </div>
      </div>
    </div>
    <div class="line-chart-container">
      <canvas id="dailyTokenChart" class="line-chart"></canvas>
      <div class="chart-tooltip hidden" id="dailyTooltip"></div>
    </div>
  </div>

  <div class="chart-row fade-up" style="animation-delay:.2s">
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="pie-chart"></i>
          Input vs Output
        </div>
      </div>
      <div id="inputOutputChart" class="donut-container">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>

    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="zap"></i>
          Cache Efficiency
        </div>
      </div>
      <div id="cacheEfficiency" class="cache-metrics">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="chart-row fade-up" style="animation-delay:.25s">
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="users"></i>
          Token Usage by Agent
        </div>
      </div>
      <div id="agentTokenChart" class="bar-chart">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>
    <div class="chart-card">
      <div class="chart-header">
        <div class="chart-title">
          <i data-lucide="cpu"></i>
          Token Usage by Model
        </div>
      </div>
      <div id="modelTokenChart" class="model-bar-chart">
        <div class="loading-state">
          <div class="icon">â³</div>
          <p>Loading data...</p>
        </div>
      </div>
    </div>
  </div>

  <div class="chart-card-full fade-up" id="agentComparisonSection" style="animation-delay:.3s;display:none">
    <div class="chart-header">
      <div class="chart-title">
        <i data-lucide="git-compare"></i>
        Agent Comparison Over Time
      </div>
      <div class="chart-subtitle">Daily token consumption per agent</div>
    </div>
    <div class="line-chart-container">
      <canvas id="agentComparisonChart" class="line-chart"></canvas>
      <div class="chart-tooltip hidden" id="comparisonTooltip"></div>
    </div>
  </div>

</main>

<script src="/layout.js"></script>
<script>
'use strict';

const $ = s => document.querySelector(s);
let tokenData = null;
let chartMode = 'lines';
let dailyChartPoints = []; // store for tooltip hit detection

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.addEventListener('layout:snapshot', () => {
  populateAgentSelect();
  loadTokens();
});

// Also load immediately â€” don't wait for SSE snapshot
setTimeout(() => {
  if (!tokenData) loadTokens();
}, 500);

// Resize handler
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => { if (tokenData) renderAll(); }, 200);
});

function populateAgentSelect() {
  const select = $('#agentSelect');
  const ids = Object.keys(agentState).sort();
  const agentOptions = ids.map(id => {
    const a = agentState[id];
    return `<option value="${id}">${a.emoji || 'ğŸ¤–'} ${a.name || id}</option>`;
  }).join('');
  select.innerHTML = '<option value="all">All Agents</option>' + agentOptions;
}

function setChartMode(mode, btn) {
  chartMode = mode;
  document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  renderDailyChart();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOAD TOKEN DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function loadTokens() {
  const range = $('#rangeSelect').value;
  const agent = $('#agentSelect').value;

  try {
    const res = await fetch(`/api/tokens?range=${range}&agent=${agent}`);
    tokenData = await res.json();
    renderAll();
  } catch (e) {
    console.error('Failed to load token data:', e);
    showToast('Failed to load token data', 'error');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER ALL CHARTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAll() {
  if (!tokenData) return;

  renderStats();
  renderDailyChart();
  renderInputOutputDonut();
  renderCacheEfficiency();
  renderAgentBreakdown();
  renderModelBreakdown();
  renderAgentComparison();

  refreshIcons();
}

function renderStats() {
  const d = tokenData;

  $('#statTotalTokens').textContent = formatNumber(d.totalTokens);
  $('#statTokensSub').textContent = `${formatNumber(d.inputTokens)} in, ${formatNumber(d.outputTokens)} out`;

  $('#statAvgTokens').textContent = formatNumber(d.avgTokensPerCall);
  $('#statAvgSub').textContent = `${formatNumber(d.apiCalls)} API calls`;

  $('#statCacheRate').textContent = d.cacheHitRate > 0 ? `${d.cacheHitRate}%` : '0%';
  $('#statCacheSub').textContent = d.cacheReadTokens > 0 ? `${formatNumber(d.cacheReadTokens)} cached` : 'No cache hits';

  $('#statTotalCost').textContent = d.totalCost > 0 ? `$${d.totalCost.toFixed(2)}` : '$0.00';
  $('#statCostSub').textContent = d.range === 'all' ? 'All time' : `Last ${d.range} days`;
}

function renderDailyChart() {
  const canvas = $('#dailyTokenChart');
  const ctx = canvas.getContext('2d');
  const tooltip = $('#dailyTooltip');
  const timeline = tokenData.overTime || [];

  if (timeline.length === 0) {
    canvas.width = canvas.parentElement.clientWidth * 2;
    canvas.height = canvas.parentElement.clientHeight * 2;
    canvas.style.width = canvas.parentElement.clientWidth + 'px';
    canvas.style.height = canvas.parentElement.clientHeight + 'px';
    ctx.scale(2, 2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-tertiary');
    ctx.font = '12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No data available', canvas.parentElement.clientWidth / 2, canvas.parentElement.clientHeight / 2);
    dailyChartPoints = [];
    return;
  }

  // Responsive canvas sizing
  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth * 2;
  canvas.height = parent.clientHeight * 2;
  canvas.style.width = parent.clientWidth + 'px';
  canvas.style.height = parent.clientHeight + 'px';
  ctx.scale(2, 2);

  const w = parent.clientWidth;
  const h = parent.clientHeight;
  const padding = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = w - padding.left - padding.right;
  const chartH = h - padding.top - padding.bottom;

  const inputColor = '#3b82f6';
  const outputColor = '#22c55e';
  const cacheColor = '#c9a44a';
  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
  const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-subtle').trim();

  const isStacked = chartMode === 'stacked';
  const maxTokens = isStacked
    ? Math.max(...timeline.map(d => d.inputTokens + d.outputTokens + d.cacheReadTokens), 1000)
    : Math.max(...timeline.map(d => Math.max(d.inputTokens, d.outputTokens, d.cacheReadTokens)), 1000);

  // Grid
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = padding.top + (chartH / 4) * i;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartW, y);
    ctx.stroke();
    const value = maxTokens * (1 - i / 4);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(formatNumber(value), padding.left - 8, y + 3);
  }

  const points = timeline.map((d, i) => {
    const x = padding.left + (chartW / (timeline.length - 1 || 1)) * i;
    let inputY, outputY, cacheY;
    if (isStacked) {
      const total = d.inputTokens + d.outputTokens + d.cacheReadTokens;
      const inputTop = d.inputTokens;
      const outputTop = inputTop + d.outputTokens;
      const cacheTop = outputTop + d.cacheReadTokens;
      inputY = padding.top + chartH - (inputTop / maxTokens * chartH);
      outputY = padding.top + chartH - (outputTop / maxTokens * chartH);
      cacheY = padding.top + chartH - (cacheTop / maxTokens * chartH);
    } else {
      inputY = padding.top + chartH - (d.inputTokens / maxTokens * chartH);
      outputY = padding.top + chartH - (d.outputTokens / maxTokens * chartH);
      cacheY = padding.top + chartH - (d.cacheReadTokens / maxTokens * chartH);
    }
    return { x, inputY, outputY, cacheY, date: d.date, input: d.inputTokens, output: d.outputTokens, cache: d.cacheReadTokens, cost: d.cost };
  });
  dailyChartPoints = points;

  const baseY = padding.top + chartH;

  if (isStacked) {
    // Stacked areas: input â†’ output â†’ cache (bottom to top)
    // Input (bottom)
    ctx.fillStyle = inputColor + '60';
    ctx.beginPath();
    ctx.moveTo(points[0].x, baseY);
    points.forEach(p => ctx.lineTo(p.x, p.inputY));
    ctx.lineTo(points[points.length - 1].x, baseY);
    ctx.closePath();
    ctx.fill();

    // Output (middle)
    ctx.fillStyle = outputColor + '60';
    ctx.beginPath();
    points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.inputY) : ctx.lineTo(p.x, p.inputY));
    for (let i = points.length - 1; i >= 0; i--) ctx.lineTo(points[i].x, points[i].outputY);
    ctx.closePath();
    ctx.fill();

    // Cache (top)
    ctx.fillStyle = cacheColor + '60';
    ctx.beginPath();
    points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.outputY) : ctx.lineTo(p.x, p.outputY));
    for (let i = points.length - 1; i >= 0; i--) ctx.lineTo(points[i].x, points[i].cacheY);
    ctx.closePath();
    ctx.fill();
  } else {
    // Independent area fills
    [[cacheColor, p => p.cacheY], [outputColor, p => p.outputY], [inputColor, p => p.inputY]].forEach(([color, yFn]) => {
      ctx.fillStyle = color + '30';
      ctx.beginPath();
      ctx.moveTo(points[0].x, baseY);
      points.forEach(p => ctx.lineTo(p.x, yFn(p)));
      ctx.lineTo(points[points.length - 1].x, baseY);
      ctx.closePath();
      ctx.fill();
    });
  }

  // Lines and dots
  const drawLine = (color, yFn) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.beginPath();
    points.forEach((p, i) => { const y = yFn(p); i === 0 ? ctx.moveTo(p.x, y) : ctx.lineTo(p.x, y); });
    ctx.stroke();
    points.forEach(p => { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(p.x, yFn(p), 3, 0, Math.PI * 2); ctx.fill(); });
  };
  if (!isStacked) {
    drawLine(inputColor, p => p.inputY);
    drawLine(outputColor, p => p.outputY);
    drawLine(cacheColor, p => p.cacheY);
  }

  // X-axis labels
  ctx.fillStyle = textColor;
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(timeline.length / 7));
  timeline.forEach((d, i) => {
    if (i % step === 0 || i === timeline.length - 1) {
      ctx.fillText(formatDate(d.date), points[i].x, baseY + 18);
    }
  });

  // Legend
  const legends = [{ color: inputColor, label: 'Input' }, { color: outputColor, label: 'Output' }, { color: cacheColor, label: 'Cache' }];
  let legendX = padding.left;
  legends.forEach(leg => {
    ctx.fillStyle = leg.color;
    ctx.fillRect(legendX, baseY + 32, 12, 12);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(leg.label, legendX + 16, baseY + 41);
    legendX += 80;
  });

  // Tooltip handler
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    let closest = null, minDist = Infinity;
    for (const p of dailyChartPoints) {
      const dist = Math.abs(p.x - mx);
      if (dist < minDist) { minDist = dist; closest = p; }
    }
    if (closest && minDist < 30) {
      tooltip.classList.remove('hidden');
      tooltip.innerHTML = `
        <div class="tooltip-date">${closest.date}</div>
        <div class="tooltip-row"><span><span class="tooltip-dot" style="background:#3b82f6"></span><span class="tooltip-label">Input</span></span><span class="tooltip-val">${formatNumber(closest.input)}</span></div>
        <div class="tooltip-row"><span><span class="tooltip-dot" style="background:#22c55e"></span><span class="tooltip-label">Output</span></span><span class="tooltip-val">${formatNumber(closest.output)}</span></div>
        <div class="tooltip-row"><span><span class="tooltip-dot" style="background:#c9a44a"></span><span class="tooltip-label">Cache</span></span><span class="tooltip-val">${formatNumber(closest.cache)}</span></div>
        <div class="tooltip-row"><span class="tooltip-label">Total</span><span class="tooltip-val">${formatNumber(closest.input + closest.output + closest.cache)}</span></div>
        ${closest.cost ? `<div class="tooltip-row"><span class="tooltip-label">Cost</span><span class="tooltip-val" style="color:var(--accent)">$${closest.cost.toFixed(4)}</span></div>` : ''}
      `;
      // Position tooltip
      const tx = Math.min(e.clientX - rect.left + 12, rect.width - 180);
      const ty = Math.max(e.clientY - rect.top - 80, 0);
      tooltip.style.left = tx + 'px';
      tooltip.style.top = ty + 'px';

      // Draw hover line
      renderDailyChart.__hoveredX = closest.x;
    } else {
      tooltip.classList.add('hidden');
    }
  };
  canvas.onmouseleave = () => { tooltip.classList.add('hidden'); };
}

function renderInputOutputDonut() {
  const container = $('#inputOutputChart');
  const d = tokenData;

  const total = d.inputTokens + d.outputTokens;
  if (total === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No token data</p></div>';
    return;
  }

  const inputPct = (d.inputTokens / total * 100);
  const outputPct = (d.outputTokens / total * 100);

  // Create canvas for donut
  const canvas = document.createElement('canvas');
  canvas.className = 'donut-canvas';
  canvas.width = 320; // 2x for retina
  canvas.height = 320;
  canvas.style.width = '160px';
  canvas.style.height = '160px';

  const ctx = canvas.getContext('2d');
  ctx.scale(2, 2);

  const centerX = 80;
  const centerY = 80;
  const radius = 60;
  const lineWidth = 24;

  // Input arc
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + (inputPct / 100 * Math.PI * 2));
  ctx.strokeStyle = '#3b82f6';
  ctx.lineWidth = lineWidth;
  ctx.stroke();

  // Output arc
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, -Math.PI / 2 + (inputPct / 100 * Math.PI * 2), -Math.PI / 2 + Math.PI * 2);
  ctx.strokeStyle = '#22c55e';
  ctx.lineWidth = lineWidth;
  ctx.stroke();

  // Center text
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
  ctx.font = '700 16px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(formatNumber(total), centerX, centerY - 8);
  ctx.font = '10px Inter, sans-serif';
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-tertiary').trim();
  ctx.fillText('total tokens', centerX, centerY + 8);

  // Legend
  const legend = document.createElement('div');
  legend.className = 'donut-legend';
  legend.innerHTML = `
    <div class="donut-legend-item">
      <div class="donut-color" style="background:#3b82f6"></div>
      <div class="donut-label">Input Tokens</div>
      <div class="donut-value">${inputPct.toFixed(1)}%</div>
    </div>
    <div class="donut-legend-item">
      <div class="donut-color" style="background:#22c55e"></div>
      <div class="donut-label">Output Tokens</div>
      <div class="donut-value">${outputPct.toFixed(1)}%</div>
    </div>
  `;

  container.innerHTML = '';
  container.appendChild(canvas);
  container.appendChild(legend);
}

function renderCacheEfficiency() {
  const container = $('#cacheEfficiency');
  const d = tokenData;

  const cacheHitRate = d.cacheHitRate || 0;
  const cacheRead = d.cacheReadTokens || 0;
  const cacheWrite = d.cacheWriteTokens || 0;
  const ratio = cacheWrite > 0 ? (cacheRead / cacheWrite).toFixed(2) : 'â€”';

  container.innerHTML = `
    <div class="cache-metric">
      <div class="cache-metric-value ${cacheHitRate > 30 ? 'good' : cacheHitRate > 10 ? 'warn' : 'info'}">${cacheHitRate}%</div>
      <div class="cache-metric-label">Cache Hit Rate</div>
      <div class="cache-metric-sub">${formatNumber(cacheRead)} tokens saved</div>
    </div>
    <div class="cache-metric">
      <div class="cache-metric-value info">${ratio}Ã—</div>
      <div class="cache-metric-label">Read/Write Ratio</div>
      <div class="cache-metric-sub">${formatNumber(cacheRead)} read, ${formatNumber(cacheWrite)} write</div>
    </div>
  `;
}

function renderAgentBreakdown() {
  const container = $('#agentTokenChart');
  const agents = tokenData.byAgent || [];

  if (agents.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No agent data</p></div>';
    return;
  }

  const maxTotal = Math.max(...agents.map(a => a.inputTokens + a.outputTokens + a.cacheReadTokens), 1);

  container.innerHTML = agents.map(a => {
    const total = a.inputTokens + a.outputTokens + a.cacheReadTokens;
    const inputPct = (a.inputTokens / maxTotal * 100);
    const outputPct = (a.outputTokens / maxTotal * 100);
    const cachePct = (a.cacheReadTokens / maxTotal * 100);

    const agentInfo = agentState[a.agentId] || {};
    const emoji = agentInfo.emoji || 'ğŸ¤–';
    const name = agentInfo.name || a.agentId;

    return `
      <div class="bar-item">
        <div class="bar-header">
          <div class="bar-label">
            <span>${emoji}</span>
            <span>${truncate(name, 20)}</span>
          </div>
          <div class="bar-total">${formatNumber(total)}</div>
        </div>
        <div class="bar-track">
          <div class="bar-segment input" style="width:${inputPct}%">
            ${inputPct > 5 ? formatNumber(a.inputTokens) : ''}
          </div>
          <div class="bar-segment output" style="width:${outputPct}%">
            ${outputPct > 5 ? formatNumber(a.outputTokens) : ''}
          </div>
          <div class="bar-segment cache" style="width:${cachePct}%">
            ${cachePct > 5 ? formatNumber(a.cacheReadTokens) : ''}
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODEL BREAKDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderModelBreakdown() {
  const container = $('#modelTokenChart');
  const models = tokenData.byModel || [];

  if (models.length === 0) {
    container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><p>No model data</p></div>';
    return;
  }

  const maxTotal = Math.max(...models.map(m => m.inputTokens + m.outputTokens + m.cacheReadTokens), 1);
  const colors = ['#3b82f6', '#22c55e', '#c9a44a', '#ef4444', '#8b5cf6', '#f59e0b', '#06b6d4', '#ec4899'];

  container.innerHTML = models.slice(0, 8).map((m, idx) => {
    const total = m.inputTokens + m.outputTokens + m.cacheReadTokens;
    const inputPct = (m.inputTokens / maxTotal * 100);
    const outputPct = (m.outputTokens / maxTotal * 100);
    const cachePct = (m.cacheReadTokens / maxTotal * 100);
    const color = colors[idx % colors.length];

    return `
      <div class="model-bar-item">
        <div class="model-bar-header">
          <div class="model-bar-name">
            <span class="model-dot" style="background:${color}"></span>
            <span>${escapeHtml(truncate(m.model, 28))}</span>
          </div>
          <div>
            <span class="model-bar-tokens">${formatNumber(total)}</span>
            ${m.cost > 0 ? `<span class="model-bar-cost"> Â· $${m.cost.toFixed(2)}</span>` : ''}
          </div>
        </div>
        <div class="model-bar-track">
          <div class="model-bar-segment" style="width:${inputPct}%;background:#3b82f6">
            ${inputPct > 8 ? formatNumber(m.inputTokens) : ''}
          </div>
          <div class="model-bar-segment" style="width:${outputPct}%;background:#22c55e">
            ${outputPct > 8 ? formatNumber(m.outputTokens) : ''}
          </div>
          <div class="model-bar-segment" style="width:${cachePct}%;background:#c9a44a">
            ${cachePct > 8 ? formatNumber(m.cacheReadTokens) : ''}
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT COMPARISON CHART
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAgentComparison() {
  const section = $('#agentComparisonSection');
  const agentTS = tokenData.agentTimeSeries || {};
  const agentIds = Object.keys(agentTS);

  // Only show when "All Agents" is selected and there are multiple
  if ($('#agentSelect').value !== 'all' || agentIds.length < 2) {
    section.style.display = 'none';
    return;
  }
  section.style.display = '';

  const canvas = $('#agentComparisonChart');
  const ctx = canvas.getContext('2d');
  const tooltip = $('#comparisonTooltip');

  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth * 2;
  canvas.height = parent.clientHeight * 2;
  canvas.style.width = parent.clientWidth + 'px';
  canvas.style.height = parent.clientHeight + 'px';
  ctx.scale(2, 2);

  const w = parent.clientWidth;
  const h = parent.clientHeight;
  const padding = { top: 20, right: 20, bottom: 40, left: 60 };
  const chartW = w - padding.left - padding.right;
  const chartH = h - padding.top - padding.bottom;

  const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
  const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-subtle').trim();
  const agentColors = ['#3b82f6', '#22c55e', '#c9a44a', '#ef4444', '#8b5cf6', '#f59e0b', '#06b6d4', '#ec4899'];

  // Build unified date axis
  const allDates = new Set();
  for (const id of agentIds) {
    for (const dp of agentTS[id]) allDates.add(dp.date);
  }
  const dates = [...allDates].sort();
  if (dates.length === 0) { section.style.display = 'none'; return; }

  // Build lookup
  const lookup = {};
  for (const id of agentIds) {
    lookup[id] = {};
    for (const dp of agentTS[id]) lookup[id][dp.date] = dp.tokens;
  }

  const maxTokens = Math.max(...dates.map(date => Math.max(...agentIds.map(id => lookup[id]?.[date] || 0))), 1000);

  // Grid
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = padding.top + (chartH / 4) * i;
    ctx.beginPath();
    ctx.moveTo(padding.left, y);
    ctx.lineTo(padding.left + chartW, y);
    ctx.stroke();
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(formatNumber(maxTokens * (1 - i / 4)), padding.left - 8, y + 3);
  }

  // Draw each agent's line
  const allPoints = {};
  agentIds.forEach((id, idx) => {
    const color = agentColors[idx % agentColors.length];
    const pts = dates.map((date, i) => {
      const tokens = lookup[id]?.[date] || 0;
      const x = padding.left + (chartW / (dates.length - 1 || 1)) * i;
      const y = padding.top + chartH - (tokens / maxTokens * chartH);
      return { x, y, tokens, date };
    });
    allPoints[id] = pts;

    // Area
    ctx.fillStyle = color + '15';
    ctx.beginPath();
    ctx.moveTo(pts[0].x, padding.top + chartH);
    pts.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(pts[pts.length - 1].x, padding.top + chartH);
    ctx.closePath();
    ctx.fill();

    // Line
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    pts.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
    ctx.stroke();

    // Dots
    pts.forEach(p => {
      if (p.tokens > 0) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  });

  // X-axis
  ctx.fillStyle = textColor;
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  const step = Math.max(1, Math.floor(dates.length / 7));
  dates.forEach((d, i) => {
    if (i % step === 0 || i === dates.length - 1) {
      const x = padding.left + (chartW / (dates.length - 1 || 1)) * i;
      ctx.fillText(formatDate(d), x, padding.top + chartH + 18);
    }
  });

  // Legend
  let legendX = padding.left;
  agentIds.forEach((id, idx) => {
    const color = agentColors[idx % agentColors.length];
    const info = window.agentState?.[id] || {};
    const label = (info.emoji || '') + ' ' + (info.name || id);
    ctx.fillStyle = color;
    ctx.fillRect(legendX, padding.top + chartH + 30, 10, 10);
    ctx.fillStyle = textColor;
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(truncate(label, 12), legendX + 14, padding.top + chartH + 39);
    legendX += 100;
  });

  // Tooltip
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    // Find closest date column
    let closestIdx = 0, minDist = Infinity;
    dates.forEach((_, i) => {
      const x = padding.left + (chartW / (dates.length - 1 || 1)) * i;
      const dist = Math.abs(x - mx);
      if (dist < minDist) { minDist = dist; closestIdx = i; }
    });
    if (minDist < 30) {
      const date = dates[closestIdx];
      tooltip.classList.remove('hidden');
      let rows = `<div class="tooltip-date">${date}</div>`;
      agentIds.forEach((id, idx) => {
        const tokens = lookup[id]?.[date] || 0;
        const info = window.agentState?.[id] || {};
        const color = agentColors[idx % agentColors.length];
        rows += `<div class="tooltip-row"><span><span class="tooltip-dot" style="background:${color}"></span><span class="tooltip-label">${escapeHtml(info.name || id)}</span></span><span class="tooltip-val">${formatNumber(tokens)}</span></div>`;
      });
      tooltip.innerHTML = rows;
      const tx = Math.min(e.clientX - rect.left + 12, rect.width - 180);
      tooltip.style.left = tx + 'px';
      tooltip.style.top = Math.max(e.clientY - rect.top - 60, 0) + 'px';
    } else {
      tooltip.classList.add('hidden');
    }
  };
  canvas.onmouseleave = () => tooltip.classList.add('hidden');
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function formatNumber(n) {
  if (n > 1e6) return (n / 1e6).toFixed(1) + 'M';
  if (n > 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toString();
}

function formatDate(dateStr) {
  const d = new Date(dateStr);
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const day = d.getDate().toString().padStart(2, '0');
  return `${month}/${day}`;
}

function truncate(str, max) {
  if (str.length <= max) return str;
  return str.slice(0, max - 1) + 'â€¦';
}

</script>
<script src="/lucide.min.js"></script>
<script>lucide.createIcons();</script>
</body>
</html>
